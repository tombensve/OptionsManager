/* 
 * 
 * PROJECT
 *     Name
 *         OptionsManager
 *     
 *     Description
 *         Manages application/tool options. Options are mapped to Java Bean properties
 *         using annotations. Help texts can be specified for options also using
 *         annotations and a complete help text can be generated by the options manager.
 *         Options can be loaded from command line arg String[] array, an XML file, or a
 *         java properties file.
 *         
 * COPYRIGHTS
 *     Copyright (C) 2009 by Natusoft AB All rights reserved.
 *     
 * LICENSE
 *     Apache 2.0 (Open Source)
 *     
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *     
 *       http://www.apache.org/licenses/LICENSE-2.0
 *     
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *     
 * AUTHORS
 *     tommy ()
 *         Changes:
 *         2014-07-09: Created!
 *         
 */
package se.natusoft.tools.optionsmgr;


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.SAXException;
import se.natusoft.tools.optionsmgr.internal.*;
import se.natusoft.tools.optionsmgr.internal.utils.XMLElement;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * This variant of OptionsManager loads XML into the option model(s) using only XML elements and no attributes.
 * This is like maven does for the &lt;configuration&gt; section of a maven plugin. This should be
 * completely compatible with the maven configuration section. If you have models that you populate in a
 * maven plugin, annotating those models, copying the configuration section and pasting it into a separate
 * file, it should also load perfectly in XMLElementOptionsManager and can be used for a command line version.
 * <p>
 * There is no need to do DTD och XML schema validation on the XML options file. The XML is parsed without
 * validation, but is validated against the specified options model to populate which can be annotated with
 * a regular expression that specifies valid values.
 * <p>
 * This class is thread safe even though the very unlikely need for that!
 * <p>
 * The &lt;T&gt; is the top level option model to manage. Due to limitations in Java Generics the
 * Class object of this model class must also be passed to the constructor.
 */
public class XMLElementOptionsManager<T> extends OptionsManager<T> {

    //
    // Arguments
    //

    /**
     * The XMLElementOptionsManagers arguments.
     */
    private static class XMLEOMArguments implements Arguments {

        /** The stream to read the XML from. */
        private InputStream xmlStream = null;

        /** If true the stream will be closed when all options XML are parsed. */
        private boolean closeStream = false;

    }

    //
    // Constructors
    //

    /**
     * Creates a new XMLElementOptionsManager.
     *
     * @param optionsModelClass The class of the top model to load options into. An instance of this will be returned on loadOptions().
     *
     * @throws OptionsModelException on failure to parse the specified model class.
     */
    public XMLElementOptionsManager(Class optionsModelClass) throws OptionsModelException {
        super(optionsModelClass, OptionsManagerType.SEQUENTIAL);
        setModelPathSeparator("/");
    }

    //
    // Methods
    //

    /**
     * Loads options model(s) from XML.
     *
     * @param xmlFile The file to load.
     *
     * @throws OptionsException On failure to load options.
     * @throws IOException on IO problems when loading options.
     */
    public T loadOptions(File xmlFile) throws OptionsException, IOException {
        XMLEOMArguments arguments = new XMLEOMArguments();
        try {
            arguments.xmlStream = new FileInputStream(xmlFile);
            arguments.closeStream = true;
        }
        catch (IOException ioe) {
            throw new OptionsException("Failed to open XML file!", ioe);
        }
        return loadOptions(arguments);
    }

    /**
     * Loads options model(s) from XML.
     * 
     * @param xmlStream The stream to load the XML from.
     *
     * @throws OptionsException On failure to load options.
     * @throws IOException on IO problems when loading options.
     */
    public T loadOptions(InputStream xmlStream) throws OptionsException, IOException {
        XMLEOMArguments arguments = new XMLEOMArguments();
        arguments.xmlStream = xmlStream;
        return loadOptions(arguments);
    }

    /**
     * Implements the populating of the model from the XML file.
     *
     * @param optionInfos Extracted information about the specified options model to populate.
     * @param arguments The same as passed to loadOptions(Arguments).
     *
     * @throws Exception on any failure.
     */
    @Override
    protected void loadOptions(OptionInfos optionInfos, Arguments arguments) throws Exception {
        XMLEOMArguments loadArguments = (XMLEOMArguments)arguments;

        Element element = parse(loadArguments.xmlStream);
        if (loadArguments.closeStream) {
            loadArguments.xmlStream.close();
        }

        Path path = new Path(element.getTagName());
        OptionInfo optInfo = optionInfos.getOptionInfoByPublicPath(path);
        if (optInfo == null || (!(optInfo instanceof OptionModelInfo))) {
            OptionInfo root = optionInfos.getAllOptionInfos().get(0);
            throw new OptionsException("Root element ('" + path + "') is invalid! Expected: '" + root.getPublicPath() + "'!");
        }

        OptionModelInfo modelInfo = (OptionModelInfo)optInfo;

        loadOptions(new XMLElement(element), path, modelInfo);
    }

    /**
     * Recursively loads childs of the specified element.
     *
     * @param element The element whose children to loop through.
     * @param publicPath the current publicPath
     * @param modelInfo The OptionModelInfo representing the current model being loaded.
     *
     * @throws OptionsException on bad XML elements.
     */
    private void loadOptions(XMLElement element, Path path, OptionModelInfo modelInfo) throws Exception {
        loadOptions(element, path, modelInfo, true);
    }

    /**
     * Recursively loads childs of the specified element.
     *
     * @param element The element whose children to loop through.
     * @param publicPath the current publicPath
     * @param modelInfo The OptionModelInfo representing the current model being loaded.
     *
     * @throws OptionsException on bad XML elements.
     */
    private void loadOptions(XMLElement element, Path path, OptionModelInfo modelInfo, boolean instantiateModel) throws Exception {
        if (instantiateModel) {
            modelInfo.instantiateModelAndAddToParent();
        }
        for (XMLElement child : element.getChildElements()) {
            
            OptionInfo optionInfo = modelInfo.getChildByName(child.getName());
            if (optionInfo == null) {
                OptionInfo collectionOptionInfo = modelInfo.getChildByName(child.getName() + "s");
                if (collectionOptionInfo != null && collectionOptionInfo.isCollectionType()) {
                    optionInfo = collectionOptionInfo;
                }
            }

            if (child.getName().equals("list") && optionInfo == null) { // We ignore the 'list' part, but only if it doesn't match a child element.
                loadOptions(child, path, modelInfo, false);
            }
            else if (optionInfo != null && optionInfo.isCollectionType() && child.getName().endsWith("s")) {
                loadOptions(child, path, modelInfo, false);
            }
            else {
                if (optionInfo == null) {
                    throw new OptionsException("The XML path '" + path.getPathAsStringSeparatedBy("/") + "/" + child.getName() +
                            "' is invalid! No matching entry in options model!");
                }

                // If no children we assume the element represents a JavaBean property value that should be set in the model.
                if (!child.elementHasChildren()) {
                    optionInfo.setValueAsString(child.getElementValue());
                }
                // otherwise the child element represents a submodel.
                else {
                    // If this matches a submodel then the OptionInfo should be a OptionModelInfo!
                    if (!(optionInfo instanceof OptionModelInfo)) {
                        throw new OptionsException("The XML path '" + path.getPathAsStringSeparatedBy("/") + "/" + element.getName() +
                                "' is invalid! Expected one of: " + modelInfo.getModelChildNamesAsCommaSeparatedString() + "!");
                    }
                    OptionModelInfo modInfo = (OptionModelInfo)optionInfo;
                    loadOptions(child, new Path(path, child.getName()), modInfo);
                }
            }
        }
    }

    /**
     * Parses the data in the specified InputStream and returns an org.e3c.dom.Element object representing the XML
     * root element.
     *
     * @param parseStream An InputStream containing the XML data to parse.
     * @throws OptionsException On options or parse failures.
     * @throws IOException on io failures.
     *
     */
    private Element parse(InputStream parseStream) throws OptionsException {
        Document document = null;
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = factory.newDocumentBuilder();
            document = docBuilder.parse(parseStream);
        }
        catch (ParserConfigurationException pce) {
            throw new OptionsException("XML parser configuration problems: " + pce.getMessage(), pce);
        }
        catch (SAXException se) {
            throw new OptionsException("XML parser failure: " + se.getMessage(), se);
        }
        catch (IOException ioe) {
            throw new OptionsException("Failed reading XML stream!", ioe);
        }

        return document.getDocumentElement();
    }

}
