package se.natusoft.tools.optionsmgr.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import se.natusoft.tools.codelicmgr.annotations.*;
import se.natusoft.tools.codelicmgr.enums.Source;

/**
 * This annotation is used to specify an option. Each option must be a JavaBean, with at least a setter.
 * It is however the bean field that should be annotated with this annotation. Only annotated fields are
 * seen by OptionsManager. You can ofcourse also provide other non annotated JavaBean properties and
 * other methods that will be completely ignored by OptionsManager.
 * <p>
 * There are 2 ways of handling bean properties that are an array or a Collection:
 * <ol>
 * <li>Provide a setter that takes just one intance of the model held by the collection and have the setter
 *     add this instance to the collection. This is not entirely correct for following the JavaBean standard,
 *     but is still JavaBean compliant since the setter will be correct for a non collection type. As far as
 *     I know the JavaBean standard only applies to setters and getters what is done in these and where the
 *     bean stores the information is irellevant as long as setters and getters behave as expected. In this
 *     case you will have a write only property. You can do exactly the same thing in a maven plugin to make
 *     the XML slightly nicer.</li>
 * <li>Provide an adder: addMyProperty(MyProperty myProperty). This makes the bean code cleaner, but completely
 *     breaks the JavaBean standard. There is however nothing stopping you from also providing a true JavaBean
 *     setter and getter for the collection property to also  make it JavaBean compliant.</li>
 * </ol>
 * <p>
 * Maps cannot be handled as easily as arrays or collections. To hanle a map create a model that takes a key
 * and a value with a setter for each and back it with a map, store the key temporarily and add to the map
 * when the value is received. 
 * <p>
 * Also note that each of the attributes of this annotation also exist as a separate annotation with only
 * one value that can be specified without the attribute name like @Description("My description")
 * and @Required. These can be used as alternatives to the attributes. None of the attributes of this annotation
 * are required. Examples:
 * <pre>
 * &nbsp;   @Option(name="myProp", description="This is my property", required=true)
 * &nbsp;   private String myProperty;
 * </pre>
 * or
 * <pre>
 * &nbsp;   @Option
 * &nbsp;   @Description("This is my property")
 * &nbsp;   @Required
 * &nbsp;   private String myProperty;
 * </pre>
 */
@Project(
    name="OptionsManager",
    description="Manages application/tool options. Options are mapped to Java Bean properties" +
                "using annotations. Help texts can be specified for options also using" +
                "annotations and a complete help text can be generated by the options manager." +
                "Options can be loaded from command line arg String[] array, an XML file, or a" +
                "java properties file."
)
@Copyright(year="2009", holder="Natusoft AB", rights="All rights reserved.")
@License(
    type="Apache",
    version="2.0",
    description="Apache Software License",
    source=Source.OPEN,
    text={
        "Licensed under the Apache License, Version 2.0 (the 'License');",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "  http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an 'AS IS' BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License."
    }
)
@Authors({
    @Author(
        name="tommy",
        email="",
        changes={
            @Change(when="2009-11-26", description="Created")
        }
    )
})
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD})
public @interface Option {

    /** A description of the option. */
    String description() default "";

    /** Force a specific name for the option. This is optional. The field name will be used otherwise. */
    String name() default "";

    /** The type of the option. Needs to be used for Collection types to identify the type of the actual option. */
    Class type() default Option.class;

    /** This should be set to true if the option is required. */
    boolean required() default false;

    /** When this is specified it should be a regular expresssion that will be applied to loaded data and throw an OptionsException if no match. */
    String validate() default "";

    /** The set of valid values accepted. */
    String[] validValues() default {};

    /**
     * If true the option is a boolean flag that do not require an argument. The argument value will always be 'true' when the option is specified.
     * This is only valid for booleans.
     */
    boolean flag() default false;
}
