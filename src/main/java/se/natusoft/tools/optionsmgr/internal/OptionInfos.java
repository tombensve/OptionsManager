package se.natusoft.tools.optionsmgr.internal;

import java.util.ArrayList;
import java.util.List;
import se.natusoft.tools.codelicmgr.annotations.*;
import se.natusoft.tools.codelicmgr.enums.Source;

/**
 * Holds a set of OptionInfo objects and provides lookup of specific getAllOptionInfos or subsets.
 */
@Project(
    name="OptionsManager",
    description="Manages application/tool options. Options are mapped to Java Bean properties" +
                "using annotations. Help texts can be specified for options also using" +
                "annotations and a complete help text can be generated by the options manager." +
                "Options can be loaded from command line arg String[] array, an XML file, or a" +
                "java properties file."
)
@Copyright(year="2009", holder="Natusoft AB", rights="All rights reserved.")
@License(
    type="Apache",
    version="2.0",
    description="Apache Software License",
    source=Source.OPEN,
    text={
        "Licensed under the Apache License, Version 2.0 (the 'License');",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "  http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an 'AS IS' BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License."
    }
)
@Authors({
    @Author(
        name="Tommy Svensson",
        email="tommy@natusoft.se",
        changes={
            @Change(when="2009-12-03", description="Created")
        }
    )
})
public class OptionInfos {

    //
    // Private Members
    //

    // Please note that the getAllOptionInfos are stored in a list and are not double stored in a couple of maps also
    // even though we can look up getAllOptionInfos by name, public path, and real path. If you have such a large
    // options model that this becomes a performance problem it is propbably not well thought trough to
    // begin with! 
    
    /** Holds the getAllOptionInfos. */
    private List<OptionInfo> optionEntries = new ArrayList<OptionInfo>();


    //
    // Methods
    //

    /**
     * Adds an OptionInfo.
     *
     * @param optionInfo The optionInfo to add.
     */
    public void addOptionInfo(OptionInfo optionInfo) {
        this.optionEntries.add(optionInfo);
    }

    /**
     * Returns the <b>first</b> OptionInfo with the specified name found or null if none where fond.
     *
     * @param name The name to lookup.
     */
    public OptionInfo getOptionInfoByName(String name) {
        OptionInfo found = null;

        for (OptionInfo optionInfo : this.optionEntries) {
            if (optionInfo.getName().equals(name)) {
                found = optionInfo;
                break;
            }
        }

        return found;
    }

    /**
     * Return the OptionInfo with the specified public path or null if not found.
     *
     * @param publicPath The public path to lookup.
     */
    public OptionInfo getOptionInfoByPublicPath(Path publicPath) {
        OptionInfo found = null;

        for (OptionInfo optionInfo : this.optionEntries) {
            if (optionInfo.getPublicPath().equals(publicPath)) {
                found = optionInfo;
                break;
            }
        }

        return found;
    }

    /**
     * Return the OptionInfo with the specified real path or null if not found.
     *
     * @param realPath The real path to lookup.
     */
    public OptionInfo getOptionInfoByRealPath(Path realPath) {
        OptionInfo found = null;

        for (OptionInfo optionInfo : this.optionEntries) {
            if (optionInfo.getRealPath().equals(realPath)) {
                found = optionInfo;
                break;
            }
        }

        return found;
    }

    /**
     * Reqturns all OptionInfo objects representing required options.
     */
    public List<OptionInfo> getRequiredOptionInfos() {
        List<OptionInfo> requiredOIs = new ArrayList<OptionInfo>();

        for (OptionInfo optionInfo : this.optionEntries) {
            if (optionInfo.isRequired()) {
                requiredOIs.add(optionInfo);
            }
        }
        
        return requiredOIs;
    }

    /**
     * Returns all OptionInfo objects representing leafs with values and not models.
     */
    public List<OptionInfo> getAllLeafOptionInfos() {
        List<OptionInfo> valueOIs = new ArrayList<OptionInfo>();

        for(OptionInfo optionInfo : this.optionEntries) {
            if (optionInfo.isLeaf()) {
                valueOIs.add(optionInfo);
            }
        }

        return valueOIs;
    }

    /**
     * Returns all the OptionInfo objects collected from the model. 
     */
    public List<OptionInfo> getAllOptionInfos() {
        return this.optionEntries;
    }

}
