package se.natusoft.tools.optionsmgr.internal;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import se.natusoft.tools.optionsmgr.OptionsException;
import se.natusoft.tools.codelicmgr.annotations.*;
import se.natusoft.tools.codelicmgr.enums.Source;
import se.natusoft.tools.optionsmgr.OptionsModelException;

/**
 * This holds information about an option and the model field it maps to. There will be one of these for
 * each [AT]Option annotated fields found in the specified model and submodels. Each instance of this
 * class will always have a OptionModelInfo as owner/parent. This class also supplies support method
 * for setting field values in the model the field belongs to to help in loading models.
 * <p>
 * All OptionInfo objects are created by OptionsManager on construction from information in the specified
 * top level options model class. They are then used when loading options into the options model.
 */
@Project(
    name="OptionsManager",
    description="Manages application/tool options. Options are mapped to Java Bean properties" +
                "using annotations. Help texts can be specified for options also using" +
                "annotations and a complete help text can be generated by the options manager." +
                "Options can be loaded from command line arg String[] array, an XML file, or a" +
                "java properties file."
)
@Copyright(year="2009", holder="Natusoft AB", rights="All rights reserved.")
@License(
    type="Apache",
    version="2.0",
    description="Apache Software License",
    source=Source.OPEN,
    text={
        "Licensed under the Apache License, Version 2.0 (the 'License');",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "  http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an 'AS IS' BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License."
    }
)
@Authors({
    @Author(
        name="Tommy Svensson",
        email="tommy@natusoft.se",
        changes={
            @Change(when="2009-12-03", description="Created")
        }
    )
})
public class OptionInfo {
    //
    // Private Members
    //

    /** A convenience and cosmetic way of using PropertyTypesHelper. */
    private static final PropertyTypesHelper Supported_Types = PropertyTypesHelper.getInstance();

    /** The name of the config value. */
    private String name = null;

    /** The type of the option. */
    private Class type = null;

    /** If true this option is required. */
    private boolean required = false;

    /** Should be set to true when a value is set for this option. */
    private boolean receivedValue = false;

    /** The description for the config value. */
    private String description = null;

    /** The property value propertyValueValidator to use. */
    private PropertyValueValidator propertyValueValidator = null;

    /** If set this OptionInfo represents a Collection type and the type is the real type stored in the collection. */
    private Class collectionType = null;

    /** 
     * If this OptionInfo represents a JavaBean property of boolean type and this is true then the option 
     * value will be forced to 'true' and the passed value will be ignored and can thus be null. 
     */
    private boolean flag = false;

    /** 
     * A '.' separated modelInst public path to the config property. A public path is a path that may include
     * annotated names. This is what should be used when loading models since it will match the external
     * representation loaded.
     */
    private Path publicPath = null;

    /**
     * A '.' separated modelInst real path to the config property. The real path is a path that always use
     * the field name and can be used to traverse the modelInst.
     */
    private Path realPath = null;

    /** The option property info */
    private PropertyInfo propertyInfo = null;

    /** The setter method for the config value. */
    private Method setterMethod = null;

    /** The option info for the model owning the option represented by this option info. */
    private OptionModelInfo owner;

    /** The OptionsManagers internal options. */
    private OMOptions omOptions = null;

    /** The current collection or null if no current collection. */
    private Collection currentCollection = null;

    //
    // Setters and getters
    //
    
    /**
     * Returns the name of the JavaBean property this OptionInfo represents.
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the name of the JavaBean property this OptionInfo represents.
     *
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the type of the JavaBean property this OptionInfo represents.
     */
    public Class getType() {
        return this.type;
    }

    /**
     * Returns true if the type is a boolean. This is a convenience method since the flag annotation
     * supports special handling of booleans.
     */
    public boolean isBooleanType() {
        return Supported_Types.getSupportedType(boolean.class).isOfType(this.type);
    }

    /**
     * Sets the type of the JavaBean property this OptionInfo represent.
     * 
     * @param type The type to set.
     */
    public void setType(Class type) {
        this.type = type;
    }

    /** 
     * Returns true if this option is required.
     */
    public boolean isRequired() {
        return this.required;
    }

    /**
     * Sets wether or not this option is required.
     *
     * @param required The required state to set.
     */
    public void setRequired(boolean required) {
        this.required = required;
    }

    /**
     * Returns true if the JavaBean property this OptionInfo represents has received a value.
     */
    public boolean hasReceivedValue() {
        return this.receivedValue;
    }

    /**
     * Returns the description of the JavaBean property this OptionInfo represents. 
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the description of the JavaBean property this OptionInfo represents. This is used for providing help text.
     * @param description the description to set.
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Returns true if this OptionInfo represents a boolean JavaBean property annotated as a flag, which means that 
     * it will be true by just having the property specified and the value is irrelevant.
     */
    public boolean isFlag() {
        return this.flag;
    }

    /**
     * Sets the flag status of this OptionInfo.
     *
     * @param flag The flag status to set.
     *
     * @see OptionInfo#isFlag() 
     */
    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    /**
     * Returns true if this OptionInfo represents a 'Collection' type.
     */
    public boolean isCollectionType() {
        return this.collectionType != null;
    }

    /**
     * Returns the Class object of the real 'Collection' type when this OptionInfo represents a
     * Collection type. Otherwise null is returned.
     */
    public Class getCollectionType() {
        return this.collectionType;
    }

    /**
     * Set to real 'Collection' impl class when this OptionInfo represents a Collection type.
     *
     * @param collectionType The class of the real 'Collection' type.
     */
    public void setCollectionType(Class collectionType) {
        this.collectionType = collectionType;
    }

    /**
     * Returns true if this is a leaf info.
     */
    public boolean isLeaf() {
        return true;
    }

    /**
     * Support method to provide a new instance of the 'Collection' type returned by getCollectionType().
     *
     * @throws OptionsModelException on failure to instantiate 'Collection' type.
     */
    public Collection createCollectionInstance() throws OptionsModelException {
        Collection collectionInstance;
        try {
            collectionInstance = (Collection)getCollectionType().newInstance();
        } catch (InstantiationException ie) {
            throw new OptionsModelException("Failed to instantiate " + getCollectionType() +" with default constructor!", ie);
        } catch (IllegalAccessException ia) {
            throw new OptionsModelException("Not allowed to instantiate " + getCollectionType() + " with default constructor!", ia);
        }

        return collectionInstance;
    }

    /**
     * Clears the current collections.
     */
    protected void clearCurrentCollection() {
        this.currentCollection = null;
    }

    /**
     * Returns the public path to the model JavaBean property represented by this OptionInfo.
     */
    public Path getPublicPath() {
        return publicPath;
    }

    /**
     * Returns the public path as a String with a correct path separator for use in error messages.
     */
    public String getErrMsgPath() {
        return getPublicPath().getPathAsStringSeparatedBy(getOMOptions().getPublicPathSeparator());
    }

    /**
     * Sets the public path to the model JavaBean property represented by this OptionInfo.
     *
     * @param publicPath the publicPath to set.
     */
    public void setPublicPath(Path publicPath) {
        this.publicPath = publicPath;
    }

    /**
     * Returns the real path to the model JavaBean property represented by this OptionInfo.
     */
    public Path getRealPath() {
        return realPath;
    }

    /**
     * Sets the real path to the model JavaBean property represented by this OptionInfo.
     *
     * @param realPath the real path to set.
     */
    public void setRealPath(Path realPath) {
        this.realPath = realPath;
    }

    /**
     * Returns the owner/parent of this option info.
     */
    public OptionModelInfo getOwner() {
        return this.owner;
    }

    /**
     * Sets the owner of this OptionInfo.
     *
     * @param owner the owner to set
     */
    public void setOwner(OptionModelInfo owner) {
        this.owner = owner;
    }

    /**
     * Returns the field of the JavaBean this OptionInfo represents.
     */
    public PropertyInfo getPropertyInfo() {
        return this.propertyInfo;
    }

    /**
     * Sets the field of the JavaBean this OptionInfo represents.
     *
     * @param field the field to set.
     */
    public void setPropertyInfo(PropertyInfo propertyInfo) {
        this.propertyInfo = propertyInfo;
    }

    /**
     * Returns the setter method of the JavaBean property this OptionInfo represent.
     */
    public Method getSetterMethod() {
        return setterMethod;
    }

    /**
     * Sets the setter method of the JavaBean property this OptionInfo represent.
     * 
     * @param setterMethod the setterMethod to set
     */
    public void setSetterMethod(Method setterMethod) {
        this.setterMethod = setterMethod;
    }

    /**
     * Returns the OptionsManagers internal options.
     */
    public OMOptions getOMOptions() {
        return this.omOptions;
    }

    /**
     * Sets the OptionsManagers internal options.
     */
    public void setOMOptions(OMOptions omOptions) {
        this.omOptions = omOptions;
    }

    /**
     * Sets the property value validator to use.
     * 
     * @param propertyValueValidator The property value propertyValueValidator to set.
     */
    public void setPropertyValueValidator(PropertyValueValidator propertyValueValidator) {
        this.propertyValueValidator = propertyValueValidator;
    }

    /**
     * Returns the property value validator.
     */
    public PropertyValueValidator getPropertyValueValidator() {
        return this.propertyValueValidator;
    }

    //
    // Support Methods
    //

    /**
     * This is a convenience method that will simply pass this call to the OptionInfo representing the owner of the option field.
     * 
     * @throws OptionsException
     * 
     * @see OptionModelInfo#assureModelInstance() for more information.
     */
    public void assureModelInstance() throws OptionsException {
        if (this.getOwner() != null && this.getOwner().getModelInstance() == null) {
            getOwner().assureModelInstance();
        }
    }

    /**
     * Sets the config value.
     *
     * @param value The value to set.
     *
     * @throws OptionsException on failure.
     */
    /*package*/ void setValue(Object value) throws OptionsException {
        if (isBooleanType() && value == null) {
            if (this.flag) {
                value = new Boolean(true);
            }
            else {
                throw new OptionsException("Invalid null value for boolean! ['" + getErrMsgPath() + "']");
            }
        }
        if (this.propertyValueValidator.hasValidation()) {
            if (!this.propertyValueValidator.isValid(value.toString())) {
                throw new OptionsException("Invalid value (" + value + ") for '" + getErrMsgPath() + "'! " + this.propertyValueValidator.getMustMatchText() + "!");
            }
        }
        if (this.owner.getModelInstance() == null) {
            throw new OMBugException("setValue(value) called without a model instace available! use instantiateModel() or assureModelInstance() before calling this!");
        }
        
        this.receivedValue = true;

        boolean doSetValue = true;
        if (isCollectionType()) {
            if (this.currentCollection == null) {
                this.currentCollection = createCollectionInstance();
                this.currentCollection.add(value);
                value = this.currentCollection;
            }
            else {
                this.currentCollection.add(value);
                // In this case we are only adding values to the 'Collection' which have already been set before.
                doSetValue = false;
            }
        }

        if (doSetValue) {
            try {
                if (this.setterMethod != null) {
                    this.setterMethod.invoke(this.owner.getModelInstance(), value);
                }
                else {
                    throw new OMBugException("No setter method for '" + getErrMsgPath() + "'!");
                }
            }
            catch(IllegalAccessException iae) {
                throw new OptionsModelException("Setter (" + this.setterMethod + ") for '" + getErrMsgPath() + "' is not accesible!", iae);
            }
            catch (InvocationTargetException ite) {
                throw new OptionsModelException("Failed setting config value (" + value + ") for '" + getErrMsgPath() + "': " + ite.getCause().getMessage(), ite.getCause());
            }
        }
    }

    /**
     * Sets the config value as a String. The String will be converted to the appropriate type.
     * All Java primitives + object variants, String, URL, and Date are supported.
     * <p>
     * OptionsManager subclasses should use this method to provide loaded option values.
     *
     * @param value The value to set.
     *
     * @throws OptionsException on failure.
     */
    public void setValueAsString(String value) throws OptionsException {
        if (this.owner.getModelInstance() == null) {
            throw new OMBugException("setStringValue(value) called without a model instace available! use instantiateModel() or assureModelInstance() before calling this!");
        }
        if (value == null && this.flag == false) {
            throw new OptionsException("Tried to set bad null value for '" + getPublicPath() + "'!");
        }

        Object realValue = null;

        try {
            realValue = Supported_Types.convertStringToTypeInstance(this.type, value, this.omOptions);
        }
        catch (OptionsException oe) {
            throw new OptionsException("Error for '" + getErrMsgPath() + "': " + oe.getMessage());
        }

        if (Supported_Types.getSupportedType(boolean.class).isOfType(this.type)) {
            if (this.isFlag()) {
                realValue = new Boolean(true);
            }
        }

        setValue(realValue);
    }

    protected void toString(StringBuilder sb) {
        sb.append("    ");
        sb.append("name=" + this.name);
        sb.append("\n    ");
        sb.append("type=" + this.type);
        sb.append("\n    ");
        sb.append("description=" + this.description);
        sb.append("\n    ");
        sb.append("publicPath=" + this.publicPath);
        sb.append("\n    ");
        sb.append("realPath=" + this.realPath);
        sb.append("\n    ");
        sb.append("flag=" + this.flag);
        sb.append("\n    ");
        sb.append("propertyInfo=" + this.propertyInfo);
        sb.append("\n    ");
        sb.append("setterMethod=" + this.setterMethod);
        sb.append("\n    ");
        sb.append("owner=" + this.owner);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("OptionInfo {\n");
        toString(sb);
        sb.append("}");
        return sb.toString();
    }

}
