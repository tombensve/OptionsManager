/* 
 * 
 * PROJECT
 *     Name
 *         OptionsManager
 *     
 *     Description
 *         Manages application/tool options. Options are mapped to Java Bean properties
 *         using annotations. Help texts can be specified for options also using
 *         annotations and a complete help text can be generated by the options manager.
 *         Options can be loaded from command line arg String[] array, an XML file, or a
 *         java properties file.
 *         
 * COPYRIGHTS
 *     Copyright (C) 2009 by Natusoft AB All rights reserved.
 *     
 * LICENSE
 *     Apache 2.0 (Open Source)
 *     
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *     
 *       http://www.apache.org/licenses/LICENSE-2.0
 *     
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *     
 * AUTHORS
 *     tommy ()
 *         Changes:
 *         2014-07-09: Created!
 *         
 */
package se.natusoft.tools.optionsmgr.internal;

import se.natusoft.tools.optionsmgr.OptionsException;
import se.natusoft.tools.optionsmgr.OptionsModelException;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collection;
import java.util.Date;

/**
 * The helper handles all supported property types.
 */
public class PropertyTypesHelper {

    /** The singleton instance. */
    private static PropertyTypesHelper propertyTypesHelper = new PropertyTypesHelper();

    //
    // Private Members
    //

    /**
     * An array of Type objects representing the supported types.
     * <p>
     * Please note that this list does not include java.util.Collection since
     * collection has special handling and these are the valid types for putting
     * in the collection in the case of a collection.
     */
    private Type[] supportedTypes = new Type[] {
        // String
        new Type(String.class, "text") {
            @Override
            protected Object stringToType(String value) {
                return value;
            }
        },
        // int/Integer
        new Type(int.class, Integer.class, "n") {
            @Override
            protected Object stringToType(String value) {
                return Integer.valueOf(value);
            }
        },
        // boolean / Boolean
        new Type(boolean.class, Boolean.class, "true/false") {
            @Override
            protected Object stringToType(String value) {
                return Boolean.valueOf(value);
            }
        },
        // long / Long
        new Type(long.class, Long.class, "n") {
            @Override
            protected Object stringToType(String value) {
                return Long.valueOf(value);
            }
        },
        // float / Float
        new Type(float.class, Float.class, "n.n") {
            @Override
            protected Object stringToType(String value) {
                return Float.valueOf(value);
            }
        },
        // double / Double
        new Type(double.class, Double.class, "n.n") {
            @Override
            protected Object stringToType(String value) {
                return Double.valueOf(value);
            }
        },
        // byte / Byte
        new Type(byte.class, Byte.class, "n") {
            @Override
            protected Object stringToType(String value) {
                return Byte.valueOf(value);
            }
        },
        // URL
        new Type(URL.class, "url") {
            @Override
            protected Object stringToType(String value) {
                URL url = null;
                try {
                    url = new URL(value);
                } catch (MalformedURLException mue) {
                    fail("Bad url specification!");
                }

                return url;
            }
        },
        // Date
        new Type(Date.class, "date") {
            @Override
            protected Object stringToType(String value) {
                Date date = getOMOptions().toDate(value);
                if (date == null) {
                    if (!hasConversionError()) {
                        fail("Unknown date format '" + value + "'");
                    }
                }

                return date;
            }
        },
        // File
        new Type(File.class,"path") {
            @Override
            protected Object stringToType(String value) {
                return new File(value);
            }
        },
        // Enum
        new Type(null, "(constrained text)") {
            @Override
            public boolean isOfType(Class type) {
                return EnumHelper.isEnum(type);
            }
            public String getTypeDescription() {
                return "Any enum";
            }
            @Override
            protected Object stringToType(String value, Class type) {
                EnumHelper enumHelper = new EnumHelper(type);
                Object enm = enumHelper.getEnumForValue(value);
                if (enm == null) {
                    fail("Invalid value '" + value + "'. Valid values are: " + enumHelper.getAvailableEnumsAsQuotedList() + ".");
                }

                return enm;
            }
        }
    };
    
    /** The OptionsManagers internal options. */
    private OMOptions omOptions = null;

    //
    // Constructors
    //

    /**
     * Creates a new instance.
     */
    private PropertyTypesHelper() {}

    //
    // Methods
    //

    /**
     * Returns the singleton instance of this helper.
     */
    public static PropertyTypesHelper getInstance() {
        return PropertyTypesHelper.propertyTypesHelper;
    }

    /**
     * Returns the Type object representing the specified type or null if the specified type is not a supported type.
     * 
     * @param type The Class object to get the Type object representing.
     */
    public Type getSupportedType(Class type) {
        Type validType = null;

        for (Type supportedType : this.supportedTypes) {
            if (supportedType.isOfType(type)) {
                validType = supportedType;
                break;
            }
        }

        return validType;
    }

    /**
     * Converts a string value to an instance of the specified type.
     *
     * @param type The type to get an instance of.
     * @param value The string value to convert.
     * @param omOptions The OptionsManagers internal options.
     * 
     * @throws OptionsException on failure to convert.
     */
    public Object convertStringToTypeInstance(Class type, String value, OMOptions omOptions) throws OptionsException {
        this.omOptions = omOptions; // Needed for converting dates. It holds supported date formats.

        Type supportedType = getSupportedType(type);
        if (supportedType != null) {
            return supportedType.convertStringToType(value, type);
        }
        else {
            throw new OptionsModelException("The property type (" + type + ") is not a supported type! Valid types are: " + getSupportedTypesAsQuotedList());
        }
    }

    /**
     * Returns true if the specified type is a supported property type.
     *
     * @param type The type to check.
     */
    public boolean isValidPropertyType(Class type) {
        return getSupportedType(type) != null;
    }

    /**
     * Returns true if the specified type is an enum.
     * 
     * @param type The type to check.
     */
    public boolean isEnum(Class type) {
        return EnumHelper.isEnum(type);
    }

    /**
     * Returns true if the specified type is a collection.
     * 
     * @param type The type to check..
     */
    public boolean isCollection(Class type) {
        return Collection.class.isAssignableFrom(type);
    }

    /**
     * Gets an enum helper for the specified enum type.
     * 
     * @param enumType The enum type to get a helper for.
     */
    public EnumHelper getEnumHelper(Class<? extends Enum> enumType) {
        return new EnumHelper(enumType);
    }

    /**
     * Returns a quoted and comma separated list of all supported types for use in error messages.
     */
    public String getSupportedTypesAsQuotedList() {
        StringBuilder sb = new StringBuilder();
        String comma = "";

        for(Type supportedType : this.supportedTypes) {
            sb.append(comma);
            sb.append('"');
            sb.append(supportedType.getTypeDescription());
            sb.append('"');
            comma = ", ";
        }

        return sb.toString();
    }

    /**
     * Returns a description of the specified type. This is for providing argument examples for help texts.
     *
     * @param type The type to get the description for.
     */
    public String getTypeDescription(Class type) {
        String desc = "";

        Type supportedType = getSupportedType(type);
        if (supportedType != null) {
            desc = supportedType.getTypeDescription();
        }

        return desc;
    }

    //
    // Inner classes
    //

    /**
     * This class wraps each supported type, supporting both primitive and object version of primitive, and other non primitive types.
     * It provides support methods for comparing and converting type.
     */
    public abstract class Type {

        //
        // Private Members
        //

        /** The primitive class representation or null if not a primitive. */
        private Class primitive = null;

        /** The primitives object variant class or a non primitive object class. */
        private Class object = null;

        /** The value representation of the type. For showing argument examples in help text. */
        private String valueTypeRepresentation = "";

        /** This will be set if stringToType fails. */
        private String convertErrorMessage = null;

        //
        // Constructors
        //

        /**
         * Creates a new Type.
         *
         * @param primitive The primitive class representation.
         * @param object The primitives object variant class.
         * @param valueTypeRepresentation For showing argument examples in help text.
         */
        public Type(Class primitive, Class object, String valueTypeRepresentation) {
            this.primitive = primitive;
            this.object = object;
            this.valueTypeRepresentation = valueTypeRepresentation;
        }

        /**
         * Creates a new Type.
         *
         * @param type The type class.
         * @param valueTypeRepresentation For showing argument examples in help text.
         */
        public Type(Class type, String valueTypeRepresentation) {
            this.object = type;
            this.valueTypeRepresentation = valueTypeRepresentation;
        }

        //
        // Methods
        //

        /**
         * Returns the value type representation for showing argument examples in help text.
         */
        public String getValueTypeRepresentation() {
            return this.valueTypeRepresentation;
        }

        /** 
         * Returns a description of the type represented by this instance. 
         */
        public String getTypeDescription() {
            String desc = null;

            if (this.primitive != null) {
                desc = this.primitive.getSimpleName() + "/" + this.object.getSimpleName();
            }
            else {
                desc = this.object.getSimpleName();
            }

            return desc;
        }

        /**
         * Returns true if the represented type is of the specified type.
         *
         * @param type The type to check.
         */
        public boolean isOfType(Class type) {
            boolean isOfType = false;

            if (this.primitive != null) {
                isOfType = type.isAssignableFrom(this.primitive) || type.isAssignableFrom(this.object);
            }
            else {
                isOfType = type.isAssignableFrom(this.object);
            }

            return isOfType;
        }

        /**
         * Returns true if the last convertStringToType(value) failed.
         */
        protected boolean hasConversionError() {
            return this.convertErrorMessage != null;
        }

        /**
         * Lets implementing subclasses report failure.
         * 
         * @param errorMessage An error message for the failure.
         */
        protected void fail(String errorMessage) {
            this.convertErrorMessage = errorMessage;
        }

        /**
         * Supply the outer OMOptions to subclasses.
         */
        protected OMOptions getOMOptions() {
            return /*outer.*/omOptions;
        }

        /**
         * Convert the string value to an instance of the represented type. 
         *
         * @param value The value to convert.
         * @param type This is needed for inexplicit types like enums. If not enum it can be null.
         *
         * @exception On failure to convert.
         */
        public Object convertStringToType(String value, Class type) throws OptionsException {
            this.convertErrorMessage = null;
            Object result = stringToType(value);
            if (result == null) {
                result = stringToType(value, type);
            }

            if (hasConversionError()) {
                throw new OptionsException(this.convertErrorMessage);
            }

            return result;
        }

        /**
         * Convert the string value to an instance of the represented type.
         *
         * @param value The string value to convert.
         */
        protected Object stringToType(String value) {
            return null;
        }

        /**
         * Convert the string value to an instance of the represented type.
         *
         * @param value The string value to convert.
         * @param type This is needed for inexplicit types like enums. If not enum it can be null.
         */
        protected Object stringToType(String value, Class type) {
            return null;
        }
    }
}
