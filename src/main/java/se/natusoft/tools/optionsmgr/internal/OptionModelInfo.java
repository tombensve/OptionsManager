/* 
 * 
 * PROJECT
 *     Name
 *         OptionsManager
 *     
 *     Description
 *         Manages application/tool options. Options are mapped to Java Bean properties
 *         using annotations. Help texts can be specified for options also using
 *         annotations and a complete help text can be generated by the options manager.
 *         Options can be loaded from command line arg String[] array, an XML file, or a
 *         java properties file.
 *         
 * COPYRIGHTS
 *     Copyright (C) 2009 by Natusoft AB All rights reserved.
 *     
 * LICENSE
 *     Apache 2.0 (Open Source)
 *     
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *     
 *       http://www.apache.org/licenses/LICENSE-2.0
 *     
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *     
 * AUTHORS
 *     tommy ()
 *         Changes:
 *         2014-07-09: Created!
 *         
 */
package se.natusoft.tools.optionsmgr.internal;

import se.natusoft.tools.optionsmgr.OptionsException;
import se.natusoft.tools.optionsmgr.OptionsModelException;

import java.util.ArrayList;
import java.util.List;

/**
 * This extends OptionInfo and represents a field that is a submodel or the top level model. It supplies
 * methods for getting children and instantiating models.
 * <p>
 * This info model can be slightly confusing. This OptionModelInfo holds an instance of the option model it
 * represents. This OptionModelInfo also extends OptionInfo, which provides setValue(value). This method
 * however as for all OptionInfo sets the value in the parent OptionModelInfo. So a setValue(value) on this
 * model will NOT set the value into this models model instance. To set a value in this models model
 * instance you need an OptionInfo that represents a child field of the model represented by this
 * OptionModelInfo.
 */
public class OptionModelInfo extends OptionInfo {

    //
    // Private Members
    //

    /**
     * The modelInst instance holding this options value. This will be assigned as a help
     * when loading models and will not be available until then, and if is used at all
     * is up to the OptionsManager subclass.
     */
    private Object modelInstance = null;

    /** Holds the OptionInfo object representing children of the model represented by this OptionModelInfo. */
    private List<OptionInfo> children = new ArrayList<OptionInfo>();

    //
    // Methods
    //

    /**
     * Returns true if this is a leaf info.
     */
    @Override
    public boolean isLeaf() {
        return false;
    }

    /**
     * Adds an OptionInfo representing a field of the model represented by this OptionModelInfo.
     * 
     * @param optionInfo The OptionInfo to add.
     */
    public void addChild(OptionInfo optionInfo) {
        this.children.add(optionInfo);
    }

    /**
     * Returns all the OptionInfo objects representing fields of the model represented by this optionModelInfo.
     */
    public List<OptionInfo> getChildren() {
        return this.children;
    }

    /**
     * Returns the child of the specified name or null if not found.
     *
     * @param name The child name to look for.
     */
    public OptionInfo getChildByName(String name) {
        OptionInfo found = null;
        for (OptionInfo optionInfo : this.children) {
            if (optionInfo.getName().equals(name)) {
                found = optionInfo;
                break;
            }
        }

        return found;
    }

    /**
     * Returns the names of the submodel children of this model as a comma separated string.
     * This is a convenience method for providing information for error messages.
     */
    public String getModelChildNamesAsCommaSeparatedString() {
        StringBuilder sb = new StringBuilder();
        String comma = "";
        for (OptionInfo optionInfo : this.children) {
            if (optionInfo instanceof OptionModelInfo) {
                sb.append(comma);
                sb.append(optionInfo.getName());
                comma = ", ";
            }
        }
        return sb.toString();
    }

    /**
     * @return The modelInst instsance if available or null otherwise.
     */
    public Object getModelInstance() {
        return this.modelInstance;
    }

    /**
     * Utility for instantiating a model for this option. The instantiated model
     * will also be saved in this object and available through getModelInstance().
     * This is safe to call several times. It will only be instantiated once.
     * When the model is instantiated it is also added to the parent.
     *
     * @throws OptionsException on any failure to instantiate the modelInst.
     */
    public Object instantiateModelAndAddToParent() throws OptionsException {
        
        OptionModelInfo owner = getOwner();
        if (owner != null && getOMOptions().getOptionsManagerType() == OptionsManagerType.RANDOM) { // null == no parent == top level model.
            // Make sure we have a parent instance!
            owner.instantiateModelAndAddToParent();
        }
        if (this.modelInstance == null || getOMOptions().getOptionsManagerType() == OptionsManagerType.SEQUENTIAL) {
            try {
                this.modelInstance = getType().newInstance();
                if (owner != null) {
                    setValue(this.modelInstance); // Add to parent.
                }
                clearChildCurrentCollections();
            }
            catch (InstantiationException ie) {
                throw new OptionsModelException("Failed to instantiate options model!", ie);
            }
            catch (IllegalAccessException iae) {
                throw new OptionsModelException("Not allowd to instantiate options model!", iae);
            }
        }

        return this.modelInstance;
    }

    /**
     * For setters with java.util.Collection types the OptionInfo class instantiates the collection type
     * and saves it locally, adding new setValues() values to the collection. When we create a new instance
     * of a parent model we have to clear the "currentCollection" of all children or we will keep adding
     * to the wrong collection. This is only a problem when this parent model also has multiple entries
     * in its parent. This is however always safe to do when called from instantiateModelAndAddToParent()
     * since the model instance is new then and no data is populated yet.
     */
    private void clearChildCurrentCollections() {
        for (OptionInfo optionInfo : this.children) {
            optionInfo.clearCurrentCollection();
        }
    }

    /**
     * This will take this option info and ensure there are models all the way from the top
     * to the one containing this option. The modelInst having this option is returned.
     * <p>
     * This is useful for simpler structures that can be "faked" with command line or
     * properties or similar by making the name into component parts. Example:
     * <pre>
     *   thirdparty.license.type
     *   thirdparty.license.version
     * </pre>
     * The above could map to a options model called Thirdparty, having a License submodel
     * with fields/options type and version.
     * <p>
     * The following would however be difficult to resolve:
     * <pre>
     *   thirdparty.licenses.license.type
     *   thirdparty.licenses.license.version
     *   thirdparty.licenses.license.type
     *   thirdparty.licenses.license.version
     * </pre>
     * This would indicate that the Licenses model has a list of License models and that adds
     * importance on the order of the input, and would also have some way of knowing that when
     * the second type comes up a new License instance must be created. This method supports
     * no such considerations. If you need to handle such structures you should use
     * instantiateModelAndAddToParent() instead and then manage the complete structure yourself. The setValue(value)
     * method on a parent with the child model as value will set the model as a child of the parent.
     * <p>
     * Please note that this method is incompatible with instantiateModelAndAddToParent()! You can call
     * either one or the other but not both! If you have called instantiateModelAndAddToParent() before
     * the call to this method it will not do anything at all!
     *
     * @throws OptionsException On any failure.
     */
    @Override
    public void assureModelInstance() throws OptionsException {
        if (this.modelInstance == null) {
            instantiateModelAndAddToParent();
            if (getOwner() != null) {
                getOwner().assureModelInstance();
                setValue(this.modelInstance);
            }
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("OptionModelInfo {\n");
        sb.append("    children=" + this.children.size());
        sb.append("\n");
        toString(sb);
        sb.append("}");
        return sb.toString();
    }

}
