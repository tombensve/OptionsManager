package se.natusoft.tools.optionsmgr;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import se.natusoft.tools.codelicmgr.annotations.*;
import se.natusoft.tools.codelicmgr.enums.Source;
import se.natusoft.tools.optionsmgr.annotations.Description;
import se.natusoft.tools.optionsmgr.internal.OptionsAnnotationHelper;
import se.natusoft.tools.optionsmgr.internal.Arguments;
import se.natusoft.tools.optionsmgr.internal.EnumHelper;
import se.natusoft.tools.optionsmgr.internal.MethodFinder;
import se.natusoft.tools.optionsmgr.internal.MethodFinder.MethodDesc;
import se.natusoft.tools.optionsmgr.internal.OMOptions;
import se.natusoft.tools.optionsmgr.internal.OptionInfos;
import se.natusoft.tools.optionsmgr.internal.OptionInfo;
import se.natusoft.tools.optionsmgr.internal.OptionModelInfo;
import se.natusoft.tools.optionsmgr.internal.OptionsManagerType;
import se.natusoft.tools.optionsmgr.internal.OptionsModelAnnotationHelper;
import se.natusoft.tools.optionsmgr.internal.Path;
import se.natusoft.tools.optionsmgr.internal.PropertyInfo;
import se.natusoft.tools.optionsmgr.internal.PropertyTypesHelper;

/**
 * Manages a hirarchy of configuration models, providing different means of populating them with
 * information. Using the description information in the annotations this class can also provide
 * a help text for all the options. 
 * <p>
 * This is a base class for managers of different option inputs, like command line, properties, or
 * XML. There are 2 types of subclasses of this class. Those that can load input of random order
 * (command line, properties) and those that require sequential ordered input (xml). The latter
 * allows for more complex option models where you can have collections or arrays of submodels,
 * which is impossible for the first type (at least I haven't figured out how to do it :-).
 * <p>
 * The &lt;T&gt; is the top level option model to manage. Due to limitations in Java Generics the
 * Class object of this model class must also be passed to the constructor.
 */
@Project(
    name="OptionsManager",
    description="Manages application/tool options. Options are mapped to Java Bean properties" +
                "using annotations. Help texts can be specified for options also using" +
                "annotations and a complete help text can be generated by the options manager." +
                "Options can be loaded from command line arg String[] array, an XML file, or a" +
                "java properties file."
)
@Copyright(year="2009", holder="Natusoft AB", rights="All rights reserved.")
@License(
    type="Apache",
    version="2.0",
    description="Apache Software License",
    source=Source.OPEN,
    text={
        "Licensed under the Apache License, Version 2.0 (the 'License');",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "  http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an 'AS IS' BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License."
    }
)
@Authors({
    @Author(
        name="Tommy Svensson",
        email="tommy@natusoft.se",
        changes={
            @Change(when="2009-11-26", description="Created")
        }
    )
})

public abstract class OptionsManager<T> {

    // Definitions
    // publicPath - The model path to a value determined by annotated names.
    // realPath - The model path to a value determined by the model property name.


    //
    // Private Members
    //

    /** A convenience and cosmetic way of using PropertyTypesHelper. */
    private static final PropertyTypesHelper Supported_Types = PropertyTypesHelper.getInstance();
    
    /** The class of the top level options model. */
    private Class<T> optionsModelClass = null;

    /** Holds the parsed/loaded config getAllOptionInfos. */
    private OptionInfos optionInfos = new OptionInfos();

    /** The OptionInfo representing the specified top level model to load. */
    private OptionModelInfo optionModelInfo = null;

    /** OptionsManagers internal options. */
    private OMOptions omOptions = null;

    //
    // Constructors
    //

    /**
     * Creates a new OptionsManager instance.
     *
     * @param optionsModelClass The class of the top level options model that this manager instance should create and populate.
     * @param optionsManagerType The type of the OptionsManager subclass: RANDOM or SEQUENTIAL.
     *
     * @throws OptionsModelException on any failure to parse model.
     */
    protected OptionsManager(Class optionsModelClass, OptionsManagerType optionsManagerType) throws OptionsModelException {
        this.optionsModelClass = optionsModelClass;
        this.omOptions = new OMOptions();
        this.omOptions.setOptionsManagerType(optionsManagerType);
        
        this.optionModelInfo = new OptionModelInfo();
        // The path to the top level options model will by default be the simple name of the class
        // with the first char converted to lowercase. To make the top level options model be
        // pathwise treated as "" that must be specified as name with an @OptionsModel(name="") annotation.
        String startPath = optionsModelClass.getSimpleName();
        startPath = startPath.substring(0, 1).toLowerCase() + startPath.substring(1);
        // The model name will also default to the model class simple name with first char converted to lowercase.
        String name = optionsModelClass.getSimpleName();
        name = name.substring(0,1).toLowerCase() + name.substring(1);
        String description = "";
        // The @OptionsModel annotaiton can override both model name and starting path.
        OptionsModelAnnotationHelper optionsModelAnn = new OptionsModelAnnotationHelper(this.optionsModelClass);
        if (optionsModelAnn.hasNameAnnotation()) {
            name = optionsModelAnn.getName();
            startPath = optionsModelAnn.getName();
        }
        if (optionsModelAnn.hasDescription()) {
            description = optionsModelAnn.getDescription();
        }

        Path publicPath = new Path(startPath);
        Path realPath = new Path(startPath);

        this.optionModelInfo.setOMOptions(this.omOptions);
        this.optionModelInfo.setName(name);
        this.optionModelInfo.setDescription(description);
        this.optionModelInfo.setType(optionsModelClass);
        this.optionModelInfo.setOwner(null);
        this.optionModelInfo.setPublicPath(publicPath);
        this.optionModelInfo.setRealPath(realPath);
        this.optionInfos.addOptionInfo(this.optionModelInfo);

        parseModel(optionsModelClass, publicPath, realPath, this.optionModelInfo);
    }

    //
    // Methods
    //

    /**
     * This finds all [at]Option annotated fields in the specified model and calls itself for found submodels.
     * For each found annotation an OptionInfo is created and populated with information about the models option,
     * for later use in populating the model with data.
     *
     * @param optionsModelClass The options model to load.
     * @param publicPath The current publicPath.
     * @param realPath The current real path.
     * @param owner The parent option info.
     *
     * @throws OptionsModelException on any failure to parse the model.
     */
    private final void parseModel(Class optionsModelClass, Path publicPath, Path realPath, OptionModelInfo owner) throws OptionsModelException {
        List<PropertyInfo> properties = new ArrayList<PropertyInfo>();

        Field[] fields = optionsModelClass.getDeclaredFields();
        for (Field field : fields) {
            PropertyInfo propInfo = new PropertyInfo(field);

            OptionsAnnotationHelper optionAnn = new OptionsAnnotationHelper(propInfo);
            if (optionAnn.isOption()) {
                propInfo.setAnnotationHelper(optionAnn);
                properties.add(propInfo);
            }
        }

        Method[] methods = optionsModelClass.getDeclaredMethods();
        for (Method method : methods) {
            PropertyInfo propInfo = new PropertyInfo(method);

            OptionsAnnotationHelper optionAnn = new OptionsAnnotationHelper(propInfo);
            if (optionAnn.isOption()) {
                propInfo.setAnnotationHelper(optionAnn);
                properties.add(propInfo);
            }
        }

        for (PropertyInfo property : properties) {
            String propertyName = property.getName();

            //Option optionAnn = property.getAnnotation(Option.class);
            OptionsAnnotationHelper optionAnn = property.getAnnotationHelper();
  

            if (optionAnn.hasName()) {
                propertyName = optionAnn.getName();
            }

            Class optionType = property.getType();
            if (optionAnn.hasType()) {
                // We let the annotated type override the real type. This is a must for List types since we have no other
                // way of determining the type of objects a list holds with reflection.
                optionType = optionAnn.getType();
            }

            if (property.isLeaf()) {
                //
                // Handle option model value property.
                //
                String name = property.getName();
                if (optionAnn.hasName()) {
                    name = optionAnn.getName();
                }

                OptionInfo optionInfo = new OptionInfo();
                optionInfo.setOMOptions(this.omOptions);
                optionInfo.setName(name);
                optionInfo.setPropertyInfo(property);
                optionInfo.setType(optionType);
                optionInfo.setRequired(optionAnn.isRequired());
                optionInfo.setDescription(optionAnn.getDescription());
                optionInfo.setPropertyValueValidator(optionAnn.getPropertyValueValidator());
                optionInfo.setPublicPath(new Path(publicPath, name));
                optionInfo.setRealPath(new Path(realPath, name));
                optionInfo.setOwner(owner);
                
                if (optionAnn.isFlag()) {
                    if (optionInfo.isBooleanType()) {
                        optionInfo.setFlag(true);
                    }
                    else {
                        throw new OptionsModelException("Invalid annotation of 'flag=true' on non boolean JavaBean property! ['" + optionInfo.getPublicPath() + "']");
                    }
                }
                owner.addChild(optionInfo);

                try {
                    String setterMethodName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                    Method setterMethod = MethodFinder.findMethod(optionsModelClass, new MethodDesc[] {
                        new MethodFinder.MethodDesc(setterMethodName, new Class[] {optionType}),
                        new MethodFinder.MethodDesc(setterMethodName + "s", new Class[] {property.getType()}),
                        new MethodFinder.MethodDesc(setterMethodName, new Class[] {property.getType()})
                    });

                    optionInfo.setSetterMethod(setterMethod);

                    // We do this here because we have just identified a Collection type setter for the property.
                    // A property can be of Collection type but have non Collection setter, which is ok.
                    if (Supported_Types.isCollection(setterMethod.getParameterTypes()[0])) {
                        if (this.omOptions.getOptionsManagerType() == OptionsManagerType.RANDOM) {
                            throw new OptionsModelException("A model with Collection bean properties has been found and this is not supported by " +
                                    getClass().getSimpleName() + "!");
                        }
                        optionInfo.setCollectionType(property.getType());
                    }
                }
                catch (NoSuchMethodException nsme) {
                    throw new OptionsModelException("No setter method for option '" + propertyName + "' in model '" + optionsModelClass.getName() + "'!");
                }

                this.optionInfos.addOptionInfo(optionInfo);
            }
            
            if (property.isBranch()) {
                //
                // Handle option model submodel property.
                //
                OptionsModelAnnotationHelper optionsModelAnn = new OptionsModelAnnotationHelper(property.getType());

                String name = property.getName();
                if (optionAnn.hasName()) {
                    name = optionAnn.getName();
                }
                else {
                    if (optionsModelAnn.hasName()) {
                        name = optionsModelAnn.getName();
                    }
                }

                String description = "";
                if (optionAnn.hasDescription()) {
                    description = optionAnn.getDescription();
                }
                else {
                    if (optionsModelAnn.hasDescription())
                    description = optionsModelAnn.getDescription();
                }

                Path modelPublicPath = new Path(publicPath, name);
                Path modelRealPath = new Path(realPath, property.getName());
                OptionModelInfo optionInfo = new OptionModelInfo();
                optionInfo.setOMOptions(this.omOptions);
                optionInfo.setName(name);
                optionInfo.setDescription(description);
                optionInfo.setPropertyInfo(property);
                optionInfo.setType(optionType);
                optionInfo.setRequired(optionAnn.isRequired());
                optionInfo.setPropertyValueValidator(optionAnn.getPropertyValueValidator());
                optionInfo.setOwner(owner);
                optionInfo.setPublicPath(modelPublicPath);
                optionInfo.setRealPath(modelRealPath);
                owner.addChild(optionInfo);

                Method setter = null;
                try {
                    String setterMethodName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                    String adderMethodName = "add" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);

                    setter = MethodFinder.findMethod(optionsModelClass, new MethodFinder.MethodDesc[] {
                        new MethodFinder.MethodDesc(setterMethodName, new Class[]{optionType}),
                        new MethodFinder.MethodDesc(setterMethodName + "s", new Class[]{property.getType()}),
                        new MethodFinder.MethodDesc(setterMethodName, new Class[]{property.getType()}),
                        new MethodFinder.MethodDesc(adderMethodName, new Class[]{optionType})
                    });

                    optionInfo.setSetterMethod(setter);

                    // We do this here because we have just identified a Collection type setter for the property.
                    // A property can be of Collection type but have non Collection setter, which is ok.
                    if (Supported_Types.isCollection(setter.getParameterTypes()[0])) {
                        if (this.omOptions.getOptionsManagerType() == OptionsManagerType.RANDOM) {
                            throw new OptionsModelException("A model with Collection bean properties has been found and this is not supported by " +
                                    getClass().getSimpleName() + "!");
                        }
                        optionInfo.setCollectionType(property.getType());
                    }
                }
                catch (NoSuchMethodException nsme) {
                    throw new OptionsModelException("No setter method for option sub model '" + propertyName + "' of type '" + optionType.getName() +
                            "' in model '" + optionsModelClass.getName() + "'!");
                }

                this.optionInfos.addOptionInfo(optionInfo);

                // Recursively call ourself to load sub model.
                parseModel(optionType, modelPublicPath, modelRealPath, optionInfo);
            }

        }

        if (!optionsModelClass.getSuperclass().getName().equals("java.lang.Object")) {
            parseModel(optionsModelClass.getSuperclass(), publicPath, realPath, owner);
        }
    }

    /**
     * Adds a SimpleDateFormat pattern for handling Date bean properties.
     * This is needed if you use any other formats than:<br>
     * "yyyy-MM-dd HH:mm"<br>
     * "yyyy-MM-dd"<br>
     * "HH:mm"
     * <p>
     * This must be called before loadOptons(...)!
     *
     * @param pattern The pattern to add.
     *
     * @see java.text.SimpleDateFormat
     */
    public void addSimpleDateFormat(String pattern) {
        this.omOptions.addSimpleDateFormat(pattern);
    }

    /**
     * Adds a DateFormat instance for handlign Date bean proprties.
     *
     * @param dateFormat The DateFormat to add.
     *
     * @see #addSimpleDateFormat(java.lang.String) 
     */
    public void addDateFormat(DateFormat dateFormat) {
        this.omOptions.addDateFormat(dateFormat);
    }

    /**
     * Sets the path separator for use when displaying model paths in error messages. 
     * <p>
     * This is usually set by OptionsManager subclasses to what matches the input format they handle, but
     * can changed by users if wanted.
     * 
     * @param publicPathSeparator
     */
    public void setModelPathSeparator(String publicPathSeparator) {
        this.omOptions.setPublicPathSeparator(publicPathSeparator);
    }

    /**
     * Use this method as an alternative to loadOptions(Arguments) if your OptionsManager subclass never
     * throws an IOException during the load process. Since loadOptions(Arguments) declare IOException to
     * be throws it must be taken care of in the code even if it will never occur, and this variant does 
     * just that. It will throw a RuntimeException if you use this incorrectly and an IOException do
     * occur!
     * <p>
     * Subclases should save their implementations specific input, call this method
     * and return its result. This will in turn call the abstract loadOptions(OptionsInfo)
     * method which will do the main work of loading the options.
     *
     * @param arguments Subclass specific input that gets passed back in loadOptions(OptionsInfo, Arguments).
     *
     * @throws OptionsException on any failure to load the options into the model.
     */
    protected final T loadOptionsNoIO(Arguments arguments) throws OptionsException {
        T result = null;

        try {
            result = loadOptions(arguments);
        }
        catch (IOException ioe) {
            throw new RuntimeException("loadOptionsNoIO(Arguments) is a convenience method that takes care of the " +
                    "IOException for those subclasses that never throws an IOException. An IOException has however been received!", ioe);
        }

        return result;
    }

    /**
     * Subclases should save their implementations specific input, call this method
     * and return its result. This will in turn call the abstract loadOptions(OptionsInfo)
     * method which will do the main work of loading the options.
     *
     * @param arguments Subclass specific input that gets passed back in loadOptions(OptionsInfo, Arguments).
     *
     * @throws OptionsException on any failure to load the options into the model.
     * @throws IOException on any IO problems when reading options input.
     */
    protected final T loadOptions(Arguments arguments) throws OptionsException, IOException {
        try {
            loadOptions(this.optionInfos, arguments);
            loadOptions(this.optionModelInfo, arguments);
        }
        catch (OptionsException oe) {
            throw oe;
        }
        catch (IOException ioe) {
            throw ioe;
        }
        catch (Exception e) {
            throw new OptionsException("Loading options failed: " + e.getMessage(), e);
        }

        return (T)this.optionModelInfo.getModelInstance();
    }

    /**
     * This needs to be implemented by subclasses to actually take the input data
     * and load it into the model. It should make use of each OptionInfo to create
     * and populate the model. This is mutualy exclusive with loadOptions(OptionModelInfo, Arguments)!
     *
     * @param optionInfos Contains the information about the model class to load and thus
     *                    also the available options.
     * @param arguments The subclass specific argument data passed to loadOptions(Arguments).
     * 
     * @throws Exception on any failure.
     */
    protected void loadOptions(OptionInfos optionInfos, Arguments arguments) throws Exception {}

    /**
     * This needs to be implemented by subclasses to actually take the input data
     * and load it into the model. This is mutualy exclusive with loadOptions(OptionInfos, Arguments)!
     *
     * @param optionModelInfo The option information representing the top level options model.
     * @param arguments The subclass specific argument data passed to loadOptions(Arguments).
     *
     * @throws Exception on any failure.
     */
    protected void loadOptions(OptionModelInfo optionModelInfo, Arguments arguments) throws Exception {}

    /**
     * This should be called after loadOptions(...) to validate that all required optionns have
     * been provided.
     *
     * @throws OptionsException on validation failure.
     */
    public void validateLoadedOptions() throws OptionsException {
        validateLoadedOptions("", ".");
    }

    /**
     * This should be called after loadOptions(...) to validate that all required optionns have
     * been provided.
     * 
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * 
     * @throws OptionsException on validation failure.
     */
    public void validateLoadedOptions(String optionPrefix, String pathSeparator) throws OptionsException {
        boolean valid = true;
        StringBuilder errors = new StringBuilder();
        for (OptionInfo optionInfo : this.optionInfos.getRequiredOptionInfos()) {
            if (!optionInfo.hasReceivedValue()) {
                errors.append("'");
                errors.append(optionPrefix);
                errors.append(optionInfo.getName().replaceAll("\\.", pathSeparator));
                errors.append("' is required, but was not provided!\n");
                valid = false;
            }
        }

        if (!valid) {
            throw new OptionsException(errors.toString());
        }
    }

    private static final String FORMAT_WORDS = Description.NL + "|" + Description.NLNL + "|" + Description.AutoLineBreaks + "|" + Description.ManualLineBreaks;

    /**
     * Returns true if the specified word is a format word.
     * 
     * @param word The word to check.
     */
    private boolean isFormatWord(String word) {
        return FORMAT_WORDS.indexOf(word) >= 0;
    }

    /**
     * Formats a string of text splitting it into several lines breaking at a specified width and
     * prefixing with a specified indent. The constants in the Description annotation provides some
     * controll over formatting. Only 2 consecutive line breaks in a row is allowed. More than that
     * will be ignored.
     *
     * @param text The text to format.
     * @param indent The indent to use.
     * @param width The width to break at.
     */
    private String formatText(String text, String indent, int width) {
        StringBuilder formatted = new StringBuilder();
        StringBuilder line = new StringBuilder();
        line.append(indent);

        boolean autoLineBreak = true;

        int nlCount = 0;

        StringTokenizer tokenizer = new StringTokenizer(text, " ");
        while(tokenizer.hasMoreTokens()) {
            String word = tokenizer.nextToken();

            if (isFormatWord(word)) {
                if (word.equals(Description.AutoLineBreaks.trim())) {autoLineBreak = true;}
                if (word.equals(Description.ManualLineBreaks.trim())) {autoLineBreak = false;}
            }
            else {
                line.append(word);
                line.append(" ");
            }
            if ((line.length() >= width && autoLineBreak) || word.equals(Description.NL.trim())) {
                ++nlCount;
            }
            else {
                nlCount = 0;
            }
            if (nlCount <= 2 && ((line.length() >= width && autoLineBreak) || word.equals(Description.NL.trim()))) {
                formatted.append(line);
                formatted.append("\n");
                line = new StringBuilder();
                line.append(indent);
            }
        }
        if (line.length() > 0) {
            formatted.append(line);
        }
        return formatted.toString();
    }

    /**
     * Prints a help text on the specified PrintStream. To write to stdout do
     * "printHelpText("-", "-", System.out)".
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * @param ps The PrintStream to write to.
     */
    public void printHelpText(String optionPrefix, String pathSeparator, PrintStream ps) {
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(ps));
        printHelpText(optionPrefix, pathSeparator, pw);
        pw.flush();
    }

    /**
     * Prints a help text on the specified PrintWriter. 
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * @param pw The PrintWriter to write to.
     */
    public void printHelpText(String optionPrefix, String pathSeparator, PrintWriter pw) {
        printHelpText(optionPrefix, pathSeparator, pw, this.optionInfos.getAllLeafOptionInfos());
    }

    /**
     * Prints a help text on the specified PrintStream. This also prints information about "branches" and  not only "leafs".
     * This is useful for sequential structured options.
     * <p>
     * To write to stdout do "printHelpText("-", "-", System.out)".
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * @param ps The PrintStream to write to.
     */
    public void printHelpTextFull(String optionPrefix, String pathSeparator, PrintStream ps) {
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(ps));
        printHelpTextFull(optionPrefix, pathSeparator, pw);
        pw.flush();
    }

    /**
     * Prints a help text on the specified PrintWriter. This also prints information about "branches" and  not only "leafs".
     * This is useful for sequential structured options.
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * @param pw The PrintWriter to write to.
     */
    public void printHelpTextFull(String optionPrefix, String pathSeparator, PrintWriter pw) {
        printHelpText(optionPrefix, pathSeparator, pw, this.optionInfos.getAllOptionInfos());
    }

     /**
     * Prints a help text on the specified PrintWriter.
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     * @param pw The PrintWriter to write to.
     */
    private void printHelpText(String optionPrefix, String pathSeparator, PrintWriter pw, List<OptionInfo> optionInfos) {
        OptionInfo topLevelModelOI = this.optionInfos.getAllOptionInfos().get(0);
        if (topLevelModelOI.getDescription().trim().length() > 0) {
            pw.println(formatText(topLevelModelOI.getDescription(), "", 64));
            pw.println();
        }
        for (OptionInfo optionInfo : optionInfos) {
            boolean display = true;
            if ((optionInfo instanceof OptionModelInfo) && optionInfo.getOwner() == null) {
                display = false;
            }
            if (display) {
                pw.print(optionPrefix);
                pw.print(optionInfo.getPublicPath().getPathAsStringSeparatedBy(pathSeparator));

                if (optionInfo.isLeaf()) {
                    if (optionInfo.isFlag()) {
                        // Don nothing!
                    }
                    else {
                        pw.print(" " + Supported_Types.getSupportedType(optionInfo.getType()).getValueTypeRepresentation());
                    }
                }

                if (optionInfo.isRequired()) {
                    pw.print(" (Required)");
                }

                if (optionInfo.isCollectionType()) {
                    if (Supported_Types.isCollection(optionInfo.getSetterMethod().getParameterTypes()[0])) {
                        String path = optionInfo.getPublicPath().getPathAsStringSeparatedBy(pathSeparator);
                        path = path + pathSeparator + optionInfo.getName().substring(0, optionInfo.getName().length() - 1);
                        pw.print(" (Takes multiple " + path + " items)");
                    }
                    else {
                        pw.print(" (This can occur multiple times!)");
                    }
                }

                if (!optionInfo.isLeaf()) {
                    pw.print(" (section)");
                }

                if (optionInfo.getPropertyValueValidator().hasValidation()) {
                    pw.println();
                    pw.println(formatText(optionInfo.getPropertyValueValidator().getMustMatchText() + ".", "    ", 60));
                }
                else if (Supported_Types.isEnum(optionInfo.getType())) {
                    EnumHelper enumHelper = Supported_Types.getEnumHelper(optionInfo.getType());
                    pw.println();
                    pw.println(formatText("Valid values are: " + enumHelper.getAvailableEnumsAsQuotedList() + ".", "    ", 60));
                }

                pw.println();
                pw.println(formatText(optionInfo.getDescription(), "    ", 60));
                pw.println();
            }
        }
    }

    /**
     * Returns a help text as a String.
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     *
     * @throws OptionsException on any failure to produce the help text.
     */
    public String getHelpTextAsString(String optionPrefix, String pathSeparator) throws OptionsException {
        String helpText = "";
        try {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            printHelpText(optionPrefix, pathSeparator, pw);
            helpText = sw.toString();
            pw.close();
            sw.close();
        }
        catch (IOException ioe) {
            throw new OptionsException("Failed to produce help text!", ioe);
        }

        return helpText;
    }

    /**
     * Returns a help text as a String.
     *
     * @param optionPrefix This will be printed before each option.
     * @param pathSeparator Options that are nested are referenced with a publicPath separated by this. Example "-" where "copyright-year"
     *                      would reference a sub model value of config property "copyright" with a "year" config property.
     *
     * @throws OptionsException on any failure to produce the help text.
     */
    public String getFullHelpTextAsString(String optionPrefix, String pathSeparator) throws OptionsException {
        String helpText = "";
        try {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            printHelpTextFull(optionPrefix, pathSeparator, pw);
            helpText = sw.toString();
            pw.close();
            sw.close();
        }
        catch (IOException ioe) {
            throw new OptionsException("Failed to produce help text!", ioe);
        }

        return helpText;
    }
}
